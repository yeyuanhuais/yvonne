### 事件流
事件流有两种模型：冒泡和捕获  
1. 冒泡：在冒泡模型中，事件首先在触发事件的元素上触发，然后逐级向上冒泡到父元素，直到达到DOM树的根节点。这就意味着事件会先触发最每层的元素，然后逐级向外触发，直到最外层的元素
2. 捕获：在捕获模型中，事件首先从DOM树的根节点开始触发，然后逐级向下捕获到触发事件的元素。这就意味着事件会从最外层的元素开始触发，然后逐级向内触发，直到最内层的元素  

在实际应用中，事件流一般会经历捕获阶段和冒泡阶段。首先，事件从根节点开始捕获，然后到达触发事件的元素，最后再冒泡回根节点。这种事件流模型被称为“捕获-目标-冒泡”模型

### 常见的性能优化
1. 减少HTTP请求：合并压缩CSS和JS文件，雪碧图减少图片请求，使用字体图标代替小图标等，减少HTTP请求次数，提高页面加载速度
2. 延迟加载：非关键资源的加载推迟到页面其他内容加载完成后再进行，懒加载或Intersection Observer API来实现延迟加载
3. 压缩和缓存：压缩CSS、JS和HTML文件，启用服务端的Gzip压缩，合理设置缓存策略，利用浏览器缓存来减少重复请求
4. 优化图片：使用适当的图片格式，并对图片进行压缩和优化
5. 使用CDN：将静态资源部署到CDN上
6. 避免重排和重绘：合理使用CSS，避免频繁的DOM操作和样式改变
7. 使用异步加载和执行：将不影响页面渲染的脚本标记为异步加载，或将脚本放在页面底部
8. 使用缓存技术：将数据缓存到客户端
9. 代码优化：避免使用过多的循环和递归
10. 使用性能分析工具：帮助识别性能瓶颈的优化机会

### 微前端的实现原理
1. 拆分应用：将整个前端应用拆分为多个独立的子应用，每个子应用负责处理特定的功能或页面
2. 独立开发：每个子应用可以由不同的团队独立开发，使用不同的技术栈和框架
3. 独立部署：每个子应用可以独立部署到不同的服务器或CDN上，可以使用不同的域名或子域名进行访问
4. 路由管理：使用主应用或路由管理来管理整个微前端应用的路由，将不同子应用的路由进行集成和管理
5. 共享状态：使用状态管理库或事件总线来实现子应用之间的状态共享和通信
6. 懒加载：根据需要动态加载子应用，避免一次性加载所有子应用，提高性能和加载速度
7. 样式隔离：使用CSS命名空间或CSS-in-JS等技术来隔离不同子应用之间的样式，避免样式冲突
8. 通信机制：使用跨域消息传递或自定义事件等机制来实现子应用之间的通信和交互

