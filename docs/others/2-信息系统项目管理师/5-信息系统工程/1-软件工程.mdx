---
hide_title: true
---

## 5.1. 软件工程
软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生产率、提高软件质量、降低软件成本。 

电气与电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE )对软件工程的定义是：将系统的、规范的、可度量的工程化方法应用于软件开发、运行和维护的全过程及上述方法的研究。

软件工程由方法、工具和过程三个部分组成：

要对软件开发的质量、进度和成本进行评估、管理和控制，包括人员组织、计划跟踪与控制、成本估算、质量保证和配置管理等。

### 5.1.1. 架构设计
软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构件的描述、构件的相互作用(连接件)、指导构件集成的模式以及这些模式的约束组成。软件架构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构件之间的对应关系，提供了一些设计决策的基本原理。

软件架构研究的主要内容涉及软件架构描述、软件架构风格、软件架构评估和软件架构的形式化方法等。 <Highlight>解决好软件的复用、质量和维护问题</Highlight> ，是研究软件架构的根本目的。

#### 5.1.1.1. 软件架构风格
软件架构设计的一个核心问题是 <Highlight>能否达到架构级的软件复用</Highlight> ，

Garlan和 Shaw对通用软件架构风格进行了分类，他们将软件架构分为：  
① 数据流风格。数据流风格包括批处理序列和管道/过滤器两种风格。  
② 调用/返回风格。调用/返回风格包括主程序/子程序、数据抽象和面向对象，以及层次结构。  
③ 独立构件风格。独立构件风格包括进程通信和事件驱动的系统。  
④ 虚拟机风格。虚拟机风格包括解释器和基于规则的系统。  
⑤ 仓库风格。仓库风格包括数据库系统、黑板系统和超文本系统。

#### 5.1.1.2. 软件架构评估
不同类型的系统需要不同的架构，甚至一个系统的不同子系统也需要不同的架构。

软件架构评估可以只针对一个架构，也可以针对一组架构。在架构评估过程中，评估人员所关注的是系统的 <Highlight>质量属性</Highlight> 。

敏感点(Sensitivity Point)和权衡点(Trade-offPoint)。敏感点是一个或多个构件(或之间的关系)的特性，权衡点是影响多个质量属性的特性，是多个质量属性的敏感点。

从目前已有的软件架构评估技术来看，可以归纳为三类主要的评估方式，分别是基于调查问卷(或检查表)的方式、基于场景的方式和基于度量的方式。这三种评估方式中，基于场景的评估方式最为常用。

基于场景的方式主要包括：架构权衡分析法(Architecture Trade-offAnalysis Method, ATAM)、软件架构分析法(Software Architecture Analysis Method, SAAM )和成本效益分析法(Cost BenefitAnalysis Method, CBAM )中。在架构评估中，一般采用刺激(Stimulus)、环 境 (Environment)和 响应(Response)三方面来对场景进行描述。

用一系列对软件的修改来反映易修改性方面的需求，用一系列攻击性操作来代表安全性方面的需求等。

不同的系统对同一质量属性的理解可能不同，例如，对操作系统来说，可移植性被理解为系统可在不同的硬件平台上运行，而对于普通的应用系统而言，可移植性往往是指该系统可在不同的操作系统上运行。由于存在这种不一致性，对一个领域适合的场景设计在另一个领域内未必合适，因此，基于场景的评估方式是特定于领域的。这一评估方式的实施者一方面需要有丰富的领域知识，以对某一质量需求设计出合理的场景；另一方面，必须对待评估的软件架构有一定的了解，以准确判断它是否支持场景描述的一系列活动。

### 5.1.2. 需求分析
软件需求是指用户对新系统在功能、行为、性能、设计约束等方面的期望。

#### 5.1.2.1. 需求的层次
软件需求就是系统必须完成的事以及必须具备的品质。需求是多层次的，包括 <Highlight>业务需求、用户需求和系统需求</Highlight> ，

质量功能部署(Quality Function Deployment, Q F D )是一种将用户要求转化成软件需求的技术，其目的是最大限度地提升软件工程过程中用户的满意度。  
QFD将软件需求分为三类，分别是 <Highlight>常规需求、期望需求和意外需求</Highlight> 。

#### 5.1.2.2. 需求过程
需求过程主要包括需求获取、需求分析、需求规格说明书编制、需求验证与确认等。

1. 需求获取
    - 需求获取是一个确定和理解不同的项目干系人的需求和约束的过程。
    - 需求获取只有与用户的有效合作才能成功。
    - 常见的需求获取方法包括用户访谈、问卷调查、采样、情节串联板、联合需求计划等。
2. 需求分析
    - 一个好的需求应该具有无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性，
    - 把杂乱无章的用户要求和期望转化为用户需求
    - 需求分析的关键在于对问题域的研究与理解。
    - 为了便于理解问题域，现代软件工程方法所推荐的做法是对问题域进行抽象，将其分解为若干个基本元素，然后对元素之间的关系进行建模。
    - 使用结构化分析（Structured Analysis, SA）方法进行需求分析，其建立的模型的核心是数据字典。围绕这个核心，有三个层次的模型，分别是 <Highlight>数据模型、功能模型和行为模型（也称为状态模型）</Highlight> 。
    - 在实际工作中，一般使用 <Highlight>实体关系图（E-R图）表示数据模型</Highlight> ，用 <Highlight>数据流图（DataFlow Diagram, DFD）表示功能模型</Highlight> ，用 <Highlight>状态转换图（State Transform Diagram, STD）表示行为模型</Highlight> 。
        -  <Highlight>E-R图</Highlight> 主要描述实体、属性，以及 <Highlight>实体之间的关系</Highlight> ；
        -  <Highlight>DFD</Highlight> 从数据传递和加工的角度，利用图形符号通过逐层细分描述系统内各个部件的功能和数据在它们之间传递的情况，来 <Highlight>说明系统所完成的功能</Highlight> ；
        -  <Highlight>STD</Highlight> 通过描述系统的状态和 <Highlight>引起系统状态转换的事件</Highlight> ，来表示系统的行为，指出作为 <Highlight>特定事件的结果将执行哪些动作</Highlight> （例如，处理数据等）。
    - 面向对象的分析（Object-Oriented Analysis, OOA） 模型包括用例模型和分析模型，
3. 需求规格说明书编制
    - 软件需求规格说明书（Software Requirement Specification, SRS）是需求开发活动的产物
    - SRS应该包含一下内容：范围、引用文件、需求、合格性规定、需求可追踪性、尚未解决的问题、注解、附录
    - SRS是软件开发过程中最重要的文档之一，对于任何规模和性质的软件项目都不应该缺少。
4. 需求验证与确认
    - 需求验证与确认活动内容包括：
        - SRS正确地描述了预期的、满足项目干系人需求的系统行为和特征；
        - SRS中的软件需求是从系统需求、业务规格和其他来源中正确推导而来的；
        - 需求是完整的和高质量的；
        - 需求的表示在所有地方都是一致的；
        - 需求为继续进行系统设计、实现和测试提供了足够的基础。
    - 一般通过需求评审和需求测试工作来对需求进行验证。需求评审就是对SRS进行技术评审，

#### 5.1.2.3. UML
统一建模语言 Unified Modeling Language, UML）是一种定义良好、易于表达、功能强大且普遍适用的建模语言，

UML的结构包括构造块、规则和公共机制三个部分

UML有三种基本的构造块，分别是事物（Thing）、关系（Relationship）和图（Diagram）。事物 是 UML的重要组成部分，关系把事物紧密联系在一起，图是多个相互关联的事物的集合

1. UML中的事物
    - UML中的事物也称为建模元素，包括结构事物（Structural Things）、行为事物（Behavioral Things,也称动作事物）、分组事物（Grouping Things）和注释事物 Annotational Things,也称注解事物）。
    - 行为事物是UML模型中的动态部分，代表时间和空间上的动作。
2. UML中的关系
    - 依 赖 (Dependency): 依赖是两个事物之间的语义关系，其中一个事物发生变化会影响另一个事物的语义。
    - 关 联 (Association): 关联描述一组对象之间连接的结构关系。
    - 泛 化 (Generalization):泛化是一般化和特殊化的关系，描述特殊元素的对象可替换一般元素的对象。
    - 实 现 (Realization): 实现是类之间的语义关系，其中的一个类指定了由另一个类保证执行的契约。
3. UML2.0中的图
    - 包括14种图：类图、对象图、构件图、组合结构图、用例图、顺序图（序列图）、通信图、定时图（计时图）、状态图、活动图、部署图、制品图、包图、交互概览图
4. UML视图
    - 逻辑视图：逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。
    - 进程视图：进程视图是可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。
    - 实现视图：实现视图对组成基于系统的物理代码的文件和构件进行建模。
    - 部署视图：部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。
    - 用例视图：用例视图是最基本的需求分析模型。

#### 5.1.2.4. 面向对象分析
OOA的任务是“做什么”，OOD的任务是“怎么做”。

面向对象分析阶段的核心工作是建立系统的用例模型与分析模型。

1. 用例模型
    - 在 OOA 方法中，构建用例模型一般需要经历四个阶段，分别是识别参与者、合并需求获得用例、细化用例描述和调整用例模型，其中前三个阶段是必须的。
    - 识别参与者
    - 合并需求获得用例
    - 细化用例描述
    - 调整用例模型
        - 包含关系：当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例
        - 扩展关系：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰
        - 泛化关系：当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系
2. 分析模型
    - 分析模型描述系统的基本逻辑结构，展示对象和类如何组成系统（静态模型），以及它们如何保持通信，实现系统行为（动态模型）。
    - 类之间的主要关系有关联、依赖、泛化、聚合、组合和实现等

<img src={require("./_images/Snipaste_2023-07-25_15-09-20.png").default}  />
<img src={require("./_images/Snipaste_2023-07-25_15-31-47.png").default}  />

### 5.1.3. 软件设计
软件设计是需求分析的延伸与拓展。需求分析阶段解决"做什么”的问题，而软件设计阶段 解 决 “怎么做”的问题。

#### 5.1.3.1. 结构化设计
结构化设计（Structured Design, SD）是一种面向数据流的方法，它 以 SRS和 SA阶段所产生 的 DFD和数据字典等文档为基础，是一个自顶向下、逐步求精和模块化的过程。SD方法的基本思想是将软件设计成由相对独立且具有单一功能的模块组成的结构，分为概要设计和详细设计两个阶段，其中概要设计又称为总体结构设计，它是开发过程中很关键的一步，其主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即系统结构图。在概要设计中，将系统开发的总任务分解成许多个基本的、具体的任务，而为每个具体任务选择适当的技术手段和处理方法的过程称为详细设计。根据任务的不同，详细设计又可分为多种，例如，输 入 /输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等。

在SD中，需要遵循一个基本的原则： <Highlight>高内聚，低耦合</Highlight> 。内聚表示模块内部各成分之间的联系程度，是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做目标单一的一件事情；耦合表示模块之间联系的程度。紧密耦合表示模块之间联系非常强，松散耦合表示模块之间联系比较弱，非耦合则表示模块之间无任何联系，是完全独立的。

#### 5.1.3.2. 面向对象设计
面向对象设计(OOD)是OOA方法的延续，其基本思想包括抽象、封装和可扩展性，其中可扩展性主要通过继承和多态来实现。在OOD中，数据结构和在数据结构上定义的操作算法封装在一个对象之中。由于现实世界中的事物都可以抽象出对象的集合，所以OOD方法是一种更接近现实世界、更自然的软件设计方法。

OOD的主要任务是对类和对象进行设计，包括类的属性、方法以及类与类之间的关系。OOD的结果就是设计模型。对于OOD而言，在支持可维护性的同时，提高软件的可复用性是一个至关重要的问题，如何同时提高软件的可维护性和可复用性，是OOD需要解决的核心问题之一。在OOD中，可维护性的复用是以设计原则为基础的。

常用的OOD原则包括：
-  <Highlight>单职原则</Highlight> ：设计功能单一的类。本原则与结构化方法的高内聚原则是一致的。
-  <Highlight>开闭原则</Highlight> ：对扩展开放，对修改封闭。
-  <Highlight>里氏替换原则</Highlight> ：子类可以替换父类。
-  <Highlight>依赖倒置原则</Highlight> ：要依赖于抽象，而不是具体实现；要针对接口编程，不要针对实现编程。
-  <Highlight>接口隔离原则</Highlight> ：使用多个专门的接口比使用单一的总接口要好
-  <Highlight>组合重用原则</Highlight> ：要尽量使用组合，而不是继承关系达到重用目的。
-  <Highlight>迪米特原则(最少知识法则)</Highlight> ：一个对象应当对其他对象有尽可能少的了解。本原则与结构化方法的低耦合原则是一致的。

#### 5.1.3.3. 设计模式
设计模式可分为类模式和对象模式。类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，属于静态关系；对象模式处理对象之间的关系，这些关系在运行时刻变化，更具动态性。

根据目的和用途不同，设计模式可分为创建型(Creational)模式、结构型(Structural)模式和行为型(Behavioral)模式三种：

设计模式可分为创建型(Creational)模式、结 构 型 (Structural)模式和行为型(Behavioral)模式三种：

### 5.1.4. 软件实现

#### 5.1.4.1. 软件配置管理
软件配置管理活动包括 <Highlight>软件配置管理计划、软件配置标识、软件配置控制、软件配置状态记录、软件配置审计、软件发布管理与交付</Highlight> 等活动。

- 软件配置管理计划的制订需要了解组织结构环境和组织单元之间的联系， <Highlight>明确</Highlight> 软件配置控制 <Highlight>任务</Highlight> 。
- 软件配置标识活动 <Highlight>识别</Highlight> 要控制的 <Highlight>配置项</Highlight> ，并为这些配置项及其版本建立基线。
- 软件配置控制关注的是 <Highlight>管理</Highlight> 软件生命周期中的 <Highlight>变更</Highlight> 。
- 软件配置状态记录标识、收集、维护并报告配置管理的 <Highlight>配置状态信息</Highlight> 。
- 软件配置审计是独立 <Highlight>评价软件产品和过程</Highlight> 是否遵从已有的规则、标准、指南、计划和流程而进行的活动。
- 软件发布管理和交付通常需要 <Highlight>创建</Highlight> 特定的 <Highlight>交付版本</Highlight> ，完成此任务的关键是软件库。

#### 5.1.4.2. 软件编码
所谓编码就是把软件设计的结果翻译成计算机可以“理解和识别”的形式————用某种程序设计语言书写的程序。

程序的质量主要取决于软件设计的质量。

1. 程序设计语言：编码之前的一项重要工作就是选择一种恰当的程序设计语言。
2. 程序设计风格：程序设计风格包括4 个方面：源程序文档化、数据说明、语句结构和输入/输出方法。应尽量从编码原则的角度提高程序的可读性，改善程序的质量
3. 程序复杂性度量：定量度量的结构可以用于比较两个不同设计或两种不同算法的优劣；程序的定量的复杂程度可以作为模块规模的精确限度。  
4. 编码效率：编码效率主要包括：① 程序效率。② 算法效率。③ 存储效率。④ I/O效率。  

#### 5.1.4.3. 软件测试
软件测试仍是发现软件错误（缺陷）的主要手段

根据国家标准GB/T15532《计算机软件测试规范》，软件测试的目的是验证软件是否满足软件开发合同或项目开发计划、系统/子系统设计文档、SRS、软件设计说明和软件产品说明等规定的软件质量要求。通过测试发现软件缺陷，为软件产品的质量测量和评价提供依据。

软件测试方法可分为静态测试和动态测试。   
1. 静态测试是指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测。静态测试包括对文档的静态测试和对代码的静态测试。对文档的静态测试主要以检查单的形式进行，而对代码的静态测试一般采用桌前检查 Desk Checking）、代码走查和代码审查。  
2. 动态测试是指在计算机上实际运行程序进行软件测试，一般采用白盒测试和黑盒测试方法。
    1. 白盒测试也称为结构测试，主要用于软件单元测试中。它的主要思想是，将程序看作是一个透明的白盒，测试人员完全清楚程序的结构和处理算法，按照程序内部逻辑结构设计测试用例，检测程序中的主要执行通路是否都能按预定要求正确工作。白盒测试方法主要有控制流测试、数据流测试和程序变异测试等。另外， <Highlight>使用静态测试的方法也可以实现白盒测试。例如，使用人工检查代码的方法来检查代码的逻辑问题，也属于白盒测试的范畴</Highlight> 。
    2. 黑盒测试也称为功能测试，主要用于集成测试、确认测试和系统测试中。黑盒测试将程序看作是一个不透明的黑盒，完全不考虑 （或不了解）程序的内部结构和处理算法，而只检查程序功能是否能按照SRS的要求正常使用，黑盒测试根据SRS所规定的功能来设计测试用例

### 5.1.5. 部署交付
需求和市场的不断变化导致软件的部署和交付不再是一个一劳永逸的过程，而是一个持续不断的过程，伴随在整个软件的开发过程中。

#### 5.1.5.1. 软件部署与交付
软件部署与交付是软件生命周期中的一个重要环节，属于软件开发的后期活动，即通过配置、安装和激活等活动来保障软件制品的后续运行。

部署与交付常存在：分支冗余导致合并困难；缺陷过多导致阻塞测试；开发环境、测试环境、部署环境不统一导致的未知错误；代码提交版本混乱无法回溯；等待上线周期过长;项目部署操作复杂经常失败；上线之后出现问题需要紧急回滚；架构设计不合理导致发生错误之后无法准确定位等困境。

#### 5.1.5.2. 持续交付
为解决部署与交付常存在的问题，持续交付应运而生，持续交付是一系列开发实践方法，用来确保让代码能够快速、安全地部署到生产环境中。

持续交付是一个完全自动化的过程，当业务开发完成的时候，可以做到一键部署。  
持续交付提供了一套更为完善的解决传统软件开发流程的方案，主要体现在：  
• 在需求阶段，抛弃了传统的需求文档的方式，使用便于开发人员理解的用户故事；  
• 在开发测试阶段，做到持续集成，让测试人员尽早进入项目开始测试；  
• 在运维阶段，打通开发和运维之间的通路，保持开发环境和运维环境的统一。  
持续交付具备的优势主要包括：  
• 持续交付能够有效缩短提交代码到正式部署上线的时间，降低部署风险；  
• 持续交付能够自动、快速地提供反馈，及时发现和修复缺陷；  
• 持续交付让软件在整个生命周期内都处于可部署的状态；  
• 持续交付能够简化部署步骤，使软件版本更加清晰；  
• 持续交付能够让交付过程成为一种可靠的、可预期的、可视化的过程。  
在评价互联网公司的软件交付能力的时候，通常会使用两个指标：  
• 仅涉及一行代码的改动需要花费多少时间才能部署上线，这也是核心指标；  
• 开发团队是否在以一种可重复、可靠的方式执行软件交付。

#### 5.1.5.3. 持续部署
1. 持续部署方案
    - 容器技术目前是部署中最流行的技术，常用的持续部署方案有Kubemetes+Docker和 Matrix系统两种。
    - 主要原因是对比传统的虚拟机技术优点主要有：
        - 容器技术上手简单，轻量级架构，体积很小；
        - 容器技术的集合性更好，能更容易对环境和软件进行打包复制和发布；
        - 容器技术的引入为软件的部署带来了前所未有的改进，不但解决了复制和部署麻烦的问题，还能更精准地将环境中的各种依赖进行完整的打包。
2. 部署原则
3. 部署层次
    - 首先要明确部署的目的并不是部署一个可工作的软件，而是部署一套可正常运行的环境。
    - 完整的镜像部署包括三个环节：Build-Ship—Run。
        - Build：跟传统的编译类似，将软件编译形成RPM包或者Jar•包；
        - Ship：则是将所需的第三方依赖和第三方插件安装到环境中；
        - Run：就是在不同的地方启动整套环境。
    - 制作完成部署包之后，每次需要变更软件或者第三方依赖以及插件升级的时候，不需要重新打包，直接更新部署包即可。
4. 不可变服务器
    - 不可变服务器是一种部署模式，是指除了更新和安装补丁程序以外，不对服务器进行任何更改。
5. 蓝绿部署和金丝雀部署
    - 在部署原则中提到两大部署方式为蓝绿部署和金丝雀部署。
    - 蓝绿部署是指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速地将用户环境切回旧版本，并对新版本进行修复和调整。
    - 金丝雀部署是指当有新版本发布的时候，先让少量用户使用新版本，并且观察新版本是否存在问题。如果出现问题，就及时处理并重新发布；如果一切正常，就稳步地将新版本适配给所有的用户。

#### 5.1.5.4. 部署与交付的新趋势
持续集成、持续交付和持续部署的出现及流行反映了新的软件开发模式与发展趋势，主要表现为：工作职责和人员分工的转变、大数据和云计算基础设施的普及进一步给部署带来新的飞跃、研发运维的融合。

### 5.1.6. 过程管理
软件过程能力是组织基于软件过程、技术、资源和人员能力达成业务目标的综合能力。

常见的软件过程管理方法和实践包括国际常用的能力成熟度模型集成（Capability Maturity Model Integration, CMML详见本书20.5.1节）和中国电子工业标准化技术协会发布的T/CESA1159《软件过程能力成熟度模型》（Software Process Capability Maturity Model）团体标准，简称 CSMM。

#### 5.1.6.1. 成熟度模型
CSMM模型由4个能力域、20个能力子域、161个能力要求组成：
1. 治理：包括战略与治理、目标管理能力子域，用于确定组织的战略、产品的方向、组织的业务目标，并确保目标的实现。
2. 开发与交付：包括需求、设计、开发、测试、部署、服务、开源应用能力子域，这些能力子域确保通过软件工程过程交付满足需求的软件，为顾客与利益干系人增加价值。
3. 管理与支持：包括项目策划、项目监控、项目结项、质量保证、风险管理、配置管理、供应商管理能力子域，这些能力子域覆盖了软件开发项目的全过程，以确保软件项目能够按照既定的成本、进度和质量交付，能够满足顾客与利益干系人的要求。
4. 组织管理：包括过程管理、人员能力管理、组织资源管理、过程能力管理能力子域，对软件组织能力进行综合管理。

|   能力域   |                                能力子域                                |
| :--------: | :--------------------------------------------------------------------: |
|    治理    |                          战略与治理、目标管理                          |
| 开发与交付 |              需求、设计、开发、测试、部署、服务、开源引用              |
| 管理与支持 | 项目策划、项目监控、项目结项、质量保证、风险管理、配置管理、供应商管理 |
|  组织管理  |           过程管理、人员能力管理、组织资源管理、过程能力管理           |

#### 5.1.6.2. 成熟度等级
<img src={require("./_images/Snipaste_2023-07-25_16-38-16.png").default}  />
<img src={require("./_images/Snipaste_2023-07-25_16-38-51.png").default}  />

整理总结
<img src={require("./_images/Snipaste_2023-07-25_16-39-32.png").default}  />