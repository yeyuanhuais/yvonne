
## 4.1. 需求分析

### ★ 4.1.1. 需求分析层次
1. 业务需求：反映<Highlight>企业或客户对系统更高层次的目标要求</Highlight>，通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等
2. 用户需求：用户能使用系统来做些什么。通常采取用户访谈和问卷调查等方式，对用户使用的场景进行整理，从而建立用户需求。<Highlight>用户的具体目标</Highlight>或用户要求系统必须能完成的任务。
3. 系统需求：从系统的角度来说明<Highlight>软件的需求，包括功能需求（系统需要完成的业务功能）、非功能需求（可靠、容错、扩展、性能等）和设计约束（限制条件、补充规约，比如有的系统软件在IE6.0下不能运行）</Highlight>等

### ★ 4.1.2. 质量功能部署（QFD）
是一种将用户要求转化成软件需求的技术，目的是最大限度地提升软件工程过程中用户地满意度。

1. 常规需求：用户认为系统应该做到地功能或性能
2. 期望需求：用户想当然认为系统应具备的功能或性能，但不能正确描述自己想要得到的这些功能或性能需求
3. 意外需求：也称为兴奋需求，用户要求外的功能或性能

### 4.1.3. 需求获取
用户访谈、问卷调查、采样、情节串联板、联合需求计划等

### ★ 4.1.4. 需求分析
:::tip
一个好的需求应该具有无二性、完整性、一致性、可测试性、正确性、必要性等特性。需要分析人员把杂乱无章的用户要求和期望转化为用户需求
:::

1. 结构化分析：SA方法，建立的模型的核心是<Highlight>数据字典</Highlight>
    1. 实体联系图（E-R图）：数据模型
    2. 数据流图（DFD）：功能模型。基本组成部分包括数据流、加工、数据存储和外部实体
    3. 状态转换图（STD）：行为模式
2. 面向对象分析：OOA模型包括用例模型和分析模型

### ★ 4.1.5. 软件需求规格说明书（SRS）
是需求开发活动的产物，编制该文档的目的是使项目干系人与开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。

1. 范围
2. 引用文件
3. 需求
4. 合格性规定
5. 需求可追踪性
6. 尚未解决的问题
7. 注解
8. 附录

### ★ 4.1.6. 需求验证（需求确认）
1. SRS正确的描述预期的、满足项目干系人需求的系统行为和特征
2. SRS中的软件需求是从系统需求、业务规格和其他来源中正确推导而来的
3. 需求是完整的和高质量的
4. 需求的表示在所有地方都是一致的
5. 需求为继续进行系统设计、实现和测试提供了足够的基础

:::note
一般通过需求评审和需求测试工作来对需求进行验证。需求评审就是对SRS进行<Highlight>技术评审</Highlight>
:::

### ★ 4.1.7. UML
:::note
一种定义良好、易于表达、功能强大且普遍适用的<Highlight>建模语言</Highlight> 

适用于各种软件开发方法、软件生命周期的各个阶段、各种应用领域以及各种开发工具。
:::
1. 构造快
2. 规则
3. 公共机制


:::note
UML的事物包括结构事物、行为事物、分组事物、注释事物
:::

### ★ 4.1.8. UML中的关系
1. 依赖：是两个事物之间的语义关系，其中一个事物发生变化会影响另一个事物的语义
2. 关联：描述一组对象之间连接的结构关系
3. 泛化：一般化和特殊化的关系，描述特殊元素的对象可替换一般元素的对象
4. 实现：类之间的语义关系，其中的一个类指定了由另一个类保证执行的契约

### ★ 4.1.9. UML2.0中的图
1. 类图：描述一组类、接口、协作和它们之间的关系。类图给出了系统的静态设计视图，活动类的类图给出了系统的静态进程试图。各种关系的强弱顺序： 泛化（Generalization） = 实现（Realization） > 组合（Composition） > 聚合（Aggregation） > 关联（Association） > 依赖（Dependency)
    1. 类图一般包括三个组成部分，第一个是类名，第二个是属性，第三个是该类提供的方法（类的性质可以放在第四部分，如果类中含有内部类，则会出现第五个组成部分）
    2. 类名部分不能省略，其他组成部分可以省略
    3. 定义了属性，则须定义其类型
2. 对象图：描述一组对象及它们之间的关系
3. 构件图：描述一个封装的类和它的接口、端口。以及由内嵌的构件和连接件构成的内部结构
4. 组合结构图：描述结构化类的内部结构，包括结构化类与系统其余部分的交互点
5. <Highlight>用例图</Highlight>：描述一组用例、参与者及它们之间的关系
    1. 在用例图中执行者与用例之间是关联关系
    2. 用来描述用户需求，主要从用户的角度描述系统的功能
6. <Highlight>顺序图（序列图）</Highlight>：是一种交互图，展现了一种交互，它由一组对象或参与者以及它们之间可能发送的消息构成。专注于系统的动态视图。顺序图是强调消息的时间次序的交互图
    1. 按执行者角色、控制类、用户接口、业务层、后台数据库进行分层，由左向右分别排列
7. <Highlight>通信图（协作图）</Highlight>：是一种交互图，它强调收发消息的对象或参与者的结构组织。<Highlight>顺序图强调的是时序，通信图强调的是对象之间的组织结构</Highlight>
8. <Highlight>定时图（计时图）</Highlight>：是一种交互图，强调消息跨越不同对象或参与者的实际时间
9.  状态图：描述一个状态机，它有状态、转移、事件和活动组成。状态图给出了对象的动态视图
10. 活动图：将进程或其他计算结构展示为计算内部一步步的控制流和数据流
11. <Highlight>部署图</Highlight>：描述对运行时的处理节点及在其中生存的构件的配置，通常一个节点包含一个或多个部署图
12. 制品图：描述计算机中一个系统的物理结构。制品包括文件、数据库和类似的物理比特集合、制品图通常与部署图一起使用。制品也给出了它们实现的类和结构
13. 包图：描述由模型本身分解而成的组织单位，以及它们之间的依赖关系
14. 交互概览图：是活动图和顺序图的混合物

### ★ 4.1.10. UML视图
1. 逻辑视图：设计视图，表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的字集
2. 进程视图：是可执行线程和进程作为活动类的建模，它是逻辑视图的一个执行实例，描述了并发与同步结构
3. 实现视图：对组成基于系统的物理代码的文件和构件进行建模
4. 部署视图：把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构
5. 用例视图：最基本的需求分析模型

### 4.1.11. 面向对象分析
OOA模型独立于具体实现，即不考虑与系统具体实现有关的因素。OOA的任务是 做什么，OOD的任务是 怎么做

面向对象分析阶段的核心工作是建立系统的用例模型与分析模型

### ★ 4.1.12. UML中的表示方式
1. 关联关系：关联提供了不同类的对象之间的结构关系，它在一段时间内将多个类的实例连接在一起
2. 依赖关系：两个类A和B，如果B的变化可能会引起A的变化，则称类A依赖于类B
3. 泛化关系：一般事物与该事物中的特殊种类之间的关系，是父类与子类之间的关系。继承关系是泛化关系的反关系
4. 共享聚集：简称聚合关系，它表示类之间的整体与部分的关系，其含义是 “部分” 可能同时属于多个 “整体”，“部分”与“整体”的生命周期可以不相同
5. 组合聚集：简称组合关系，表示类之间的整体和部分的关系
6. 实现关系：将说明和实现联系起来

<img src={require("./_images/Snipaste_2022-11-21_16-44-00.png").default} />

## 4.2. 软件架构设计

### ★ 4.2.1. 软件架构风格
软件架构设计的一个核心问题是能否达到架构级的软件复用，也就是说，能否在不同的系统中。
1. 数据流风格：数据流风格包括批处理序列和管道/过滤器两种风格
2. 调用/返回风格：调用/返回风格包括主程序/子程序、数据抽象和面向对象，以及层次结构
3. 独立构件风格：包括进程通信和事件驱动的系统
4. 虚拟机风格：包括解释器和基于规则的系统
5. 仓库风格：包括数据库系统、黑板系统和超文本系统

### ★ 4.2.2. 软件架构评估
:::note
敏感点是一个或多个构件（和或构件之间的关系）的特性，权衡点是影响多个质量属性的特性，是多个质量属性的敏感点
:::

:::tip
研究软件架构地根本目的是解决软件的复用、质量和维护问题，软件架构设计是开发过程中关键的一步，因此需要对其进行评估，在这一活动中，评估人员关注的是系统的质量属性
:::

1. 基于调查问卷（或检查表）的方式
2. 基于场景的方式：
    1. 架构权衡分析法（ATAM）、软件架构分析法（SAAM）、成本效益分析法（CBAM）。
    2. 一般采用刺激、环境、响应三方面来对场景进行描述
    3. 刺激场景中解释或描述项目干系人怎么引发与系统的交互部分，环境描述的是刺激发生时的情况，响应是指系统是如何通过架构对刺激作出反映的
3. 基于度量的方式

## 4.3. 软件设计

### 4.3.1. 结构化设计
SD是一种面向数据流的方法，它以SRS和SA阶段所产生的DFD和数据字典等文档为基础，是一个自顶向下、逐步求精和模块化的过程。分为概要设计和详细设计两个阶段。

基本原则：<Highlight>高内聚，低耦合</Highlight>

### ★ 4.3.2. 面向对象设计
基本思想：包括抽象、封装和可扩展性，其中可扩展性主要通过继承和多态来实现

<Highlight>特征：继承性、封装性、多态性</Highlight>

:::tip
为了将面向对象的分析模型转化为设计模型，设计人员必须完成一下任务：设计用例实现方案、设计技术支出设施、设计用户界面、精华设计模型
:::

### ★ 4.3.3. 设计模式
设计模式是前人经验的总结，它使人们可以方便的复用成功的软件设计

1. 处理范围：分为类模式和对象模式
2. 目的和用途：创建型模式（创建对象）、结构型模式（处理类或对象的组合）、行为型模式（描述类或对象的交互以及职责的分配）

:::tip
对象模式在运行时刻变化的，动态性的，而不是静态关系
:::

## ★ 4.4. 软件工程的过程管理
软件过程是软件生命周期中的一系列相关活动，即用于开发和维护软件及相关产品的一系列活动。

在软件过程管理方面，最著名的是能力成熟度模型集成

:::note
能力成熟度模型集成（CMMI），它融合了多种模型，形成了组织范围内过程改进的单一集成模型，其主要目的是消除不同模型之间的不一致和重复，降低基于模型进行改进的成本。

<Highlight>CMMI的阶段表示法和EIA/IS731的连续式表示法，均采用统一的24个过程域，它们在逻辑上的等价的，对同一个组织采用两种模型分别进行CMMI评估，得到的结论应该是相同的</Highlight>

<Highlight>成熟度级别3级与4级的关键区别在于对过程性能的可预测性</Highlight>
:::

### ★ 4.4.1. 阶段式模型（成熟度等级）
| 成熟度等级                        | 过程域                                                                                                                                                                                    |
| --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 可管理级                          | 需求管理、项目计划、配置管理、项目监督与控制、供应商合同管理、度量和分析、过程和产品质量保证                                                                                              |
| 已定义级                          | <Highlight>需求开发、技术解决方案、产品集成、验证、确认、组织级过程焦点、组织级过程定义、组织级培训、集成项目管理、风险管理、集成化的团队、决策分析和解决方案、组织级集成环境</Highlight> |
| <Highlight>量化管理级</Highlight> | <Highlight>组织级过程性能、定量项目管理</Highlight>                                                                                                                                       |
| 优化管理级                        | 组织级改革与实施、因果分析和解决方案                                                                                                                                                      |

### ★ 4.4.2. 连续式模型（表示过程能力）
| 连续式分组                      | 过程域                                                                                                              |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| <Highlight>过程管理</Highlight> | 组织级过程焦点、组织级过程定义、组织级培训、组织级过程性能、组织级改革与实施                                        |
| <Highlight>项目管理</Highlight> | <Highlight>项目计划、项目监督与控制、供应商合同管理、集成项目管理、风险管理、集成化的团队、定量项目管理</Highlight> |
| <Highlight>工程</Highlight>     | 需求管理、需求开发、技术解决方案、产品集成、验证、确认                                                              |
| <Highlight>支持</Highlight>     | 配置管理、度量和分析、过程和产品质量保证、决策分析和解决方案、组织级集成环境、因果分析和解决方案                    |

## 4.5. 软件测试及其管理
每个测试用例应包括名称和标识、测试追踪、用例说明、测试的初始化要求、测试的输入、期望的测试结果、评价测试结果的准则、操作过程、前提和约束、测试终止条件。

### ★ 4.5.1. 测试的方法
<Highlight>静态测试和动态测试</Highlight>

1. 静态测试：
    1. 文档的静态测试：主要以检查单的形式进行
    2. 代码的静态测试：<Highlight>桌前检查（Desk Checking）、代码走查和代码审查</Highlight>
2. 动态测试：
    1. 白盒测试（结构测试）：
        1. 主要用于单元测试中
        2. 测试人员完全清楚程序的结构和处理算法，安装程序内部逻辑结构设计测试用例，检测程序中的主要执行通路是否能按预定要求正确工作。
        3. 主要的方法有控制流测试、数据流测试和程序变异测试等
        4. 使用静态测试的方法也可以实现白盒测试
        5. 最常用的技术是逻辑覆盖，即使用测试数据运行被测程序，考察对程序逻辑的覆盖程度。主要的覆盖标准有语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、条件组合覆盖、修正的条件/判定覆盖和路径覆盖等。
    2. 黑盒测试（功能测试）：
        1. 主要用于集成测试、确认测试和系统测试中
        2. 完全不考虑程序内部结构和处理算法，而只检查程序功能是否按照SRS的要求正常使用，程序是否能适当的接收输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息的完整性
        3. 等价类划分、边界值分析、判定表、因果图、状态图、随机测试、猜错法和正交试验法等。

### ★ 4.5.2. 测试的类型 
单元测试、集成测试、确认测试、系统测试、配置项测试和回归测试等类别

1. 单元测试（模块测试）：
    1. 测试的对象是可独立编译或汇编的程序模块、软件构件或OO软件中的类（统称模块）
    2. 目的是检查每个模块能否正确的实现设计说明中的功能、性能、接口和其他设计约束等条件，发现模块内可能存在的各种差错
    3. 依据软件详细设计说明书
2. 集成测试：
    1. 目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证以集成的软件是否符合设计要求
    2. 依据软件概要设计文档
3. 确认测试：
    1. 主要验证软件的功能、性能和其他特性是否与用户需求一致
    2. 内部确认测试：主要由软件开发组织内部按照SRS进行测试
    3. Alpha测试：由用户在开发环境下进行测试
    4. Beta测试：由用户在实际使用环境下进行测试
    5. 验收测试：针对SRS，在交付前以用户为主进行的测试。
        1. 测试的目的是在真实的用户工作环境下，校验软件西戎是否满足开发技术合同或SRS
4. 系统测试：
    1. 目的是在真实系统工作环境下，验证完整的软件配置项能否和系统正确连接，并满足系统/子系统设计文档和软件开发合同规定要求
    2. 主要包括功能测试、健壮性测试、性能测试、用户界面测试、安全性测试、安装与反安装测试等。
    3. 依据用户需求或开发合同
5. 配置项测试：
    1. 目的是检验软件配置项与SRS的一致性
    2. 依据是SRS（含接口需求规格说明）
6. 回归测试：
    1. 目的是测试软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的，正确的功能、性能和其他规定的要求的不损害性。回归测试不能影响其他正常的功能

### 4.5.3. 软件调试
<Highlight>蛮力法、回溯法、原因排除法</Highlight>

区别主要体现在一下几个方面
1. 测试的目的是找出存在的错误，而调试的目的是定位错误并修改程序以修正错误
2. 调试是测试之后的活动。测试和调试在目标、方法和思路上都有所不同
3. 测试从一个已知的条件开始，使用预先定义的过程，有预知的结果；调试从一个未知的条件开始，结束的过程不可预计
4. 测试过程可以事先设计，进度可以事先确定；调试不能描述过程或持续时间

### ★ 4.5.4. 软件测试管理
1. 过程管理：包括测试活动管理和测试资源管理。软件测试应由相对独立的人员进行
    1. <Highlight>全部测试工具、被测软件、测试支持软件和评审结果已纳入配置管理</Highlight>
2. 配置管理：应按照软件配置管理的要求，将测试过程中产生的各种工作产品纳入配置管理
3. 评审：测试过程中的评审包括测试就绪评审和测试评审

## 4.6. 软件集成技术
企业应用集成（EAI）：软件层次地集成技术

EAI所连接地应用包括各种电子商务系统、ERP、CRM、SCM、OA、数据库系统和数据仓库等

:::tip
表示集成、数据集成、控制集成、业务流程集成的灵活性和复杂度逐渐增强
:::
### ★ 4.6.1. 表示集成（界面集成）
表示集成是黑盒集成

1. 在现有的基于终端的应用系统上配置基于PC的用户界面
2. 为用户提供一个看上去统一，但是由多个系统组成的应用系统
3. 当只有可能在显示界面上实现集成时
4. 常用的集成技术主要有屏幕截取和输入模拟技术

<img src={require("./_images/Snipaste_2022-11-21_14-54-13.png").default} />

### 4.6.2. 数据集成
数据集成是白盒集成

<Highlight>在集成之前，必须首先对数据进行标识并编成目录，另外还有确定元数据模型，保证数据在数据库系统中分布和共享</Highlight>

1. 需要对多种信息源产生的数据进行综合分析和决策
2. 要处理一些多个应用系统需要访问的公用信息库
3. 当需要从某数据源获得数据来更新另一个数据源时，特别是它们之间的数据格式不相同时

<img src={require("./_images/Snipaste_2022-11-21_14-57-50.png").default} />

### ★ 4.6.3. 控制集成（功能集成或应用集成）
<Highlight>是在业务逻辑层上对应用系统进行集成的</Highlight>

控制集成是黑盒集成

<img src={require("./_images/Snipaste_2022-11-21_14-58-39.png").default} />

### 4.6.4. 业务流程集成（过程集成）
这种集成超越了数据和系统，它由一系列基于标准的、统一数据格式的工作流组成

### ★ 4.6.5. 企业之间的应用集成
EAI技术可以适用于大多数要实施电子商务的企业，以及企业之间的应用集成。EAI使得应用集成架构里的客户和业务伙伴，都可以通过集成供应链内的所有应用和数据库实现信息共享。能够使企业充分利用外部资源。

## ★ 面向对象的基本概念
包括对象、类、抽象、封装、继承、多态、接口、消息、组件、复用和模式等

1. 对象：
    1. 由数据及其操作所构成的封装体，是系统中用来描述客观事物的一个模块，是构成系统的基本单位。
    2. 用计算机语言来描述，对象是由一组属性和对这组属性进行的操作构成的。
    3. 对象包含三个基本要素，分别是对象标识、对象状态和对象行为
2. 类：
    1. 现实世界中实体的形式化描述，类将该实体的属性（数据）和操作（函数）封装在一起
    2. 类和对象的关系可理解为，对象是类的实例，类是对象的模板。如果将对象比作房子，那么类就是房子的设计图纸
3. 抽象：
    1. 通过特定的实例抽取共同特征以后形成概念的过程
    2. 抽象是一种单一化的描述，强调给出与应用相关的特性，抛弃不相关的特性
    3. 对象是现实世界中某个实体的抽象，类是一组对象的抽象
4. 封装：
    1. 将相关的概念组成一个单元模块，并通过一个名称来引用它
    2. 面向对象封装是将数据和基于数据的操作封装成一个整体对象，对数据的访问或修改只能通过对象对外提供的接口进行
5. 继承：
    1. 表示类之间的层次关系（父类与子类），这种关系使得某类对象可以继外一类对象的特征
    2. 继承又可以分为单继承和多继承
6. 多态：
    1. 使得在多个类中可以定义同一个操作或属性名，并且在每个类中可以有不同的实现。
    2. 多态使得某个属性或操作在不同的时期可以表示不同类的对象特性
7. 接口：
    1. 描述对操作规范的说明，其只说明操作应该做什么，并没有定义操作如何做
    2. 可以将接口理解成为类的一个特例，它规定了实现此接口的类的操作方法，把真正的实现细节交由实现该接口的类去完成
8. 消息：
    1. 体现对象间的交互，通过它向目标对象发送操作请求
9. 组件：
    1.  表示软件系统可替换的、物理的组成部分，封装了模块功能的实现。
    2.  组件应当是内聚的，并具有相对稳定的公开接口
10. 复用：
    1.  指将己有的软件及其有效成分用于构造新的软件或系统。
    2.  组成技术软件复用实现的关键
11. 模式：
    1.  描述了一个不断重复发生的问题，以及该问题的解决方案。
    2.  包括特定环境、问题和解决方案三个组成部分
    3.  应用设计模式可以更加简单和方便地去复用成功地软件设计和架构，从而帮助设计者更快更好地完成系统设计

## ★ 软件审计
目的是提供软件产品和过程对于可应用的规则、标准、指南、计划和流程的遵从性的独立评价

审计师正式组织的活动，识别违例情况，并要生成审计报告，采取更正性行动

## ★ 评审与审计
包括管理评审、技术评审、检查、走查、审计等

管理评审的目的是监控进展，决定计划和进度的状态，确认需求及其系统分配，或评价用于达到目标所用管理方法的有效性。它们支持有关软件项目期间需求的变更和其他变更活动。是评
价管理方面。

技术评审的目的是评价软件产品，以确定其对使用意图的适用性。目标是识别规范说明和标准的差异，并向管理提供证据，以表明产品是否满足规范说明并遵从标准，而且可以控制变更。是评价技术方面。

## ★ 对象模型技术
对象模型技术把分析时收到的信息构造在三类模型中，即对象模型、功能模型和动态模型。三个模型从不同的角度对系统进行描述，分别着重于系统的一个方面，组合起来构成对系统的完整描述。

形象的说，功能模型定义“做什么”，状态模型定义“何时做”，对象模型定义“对谁做”。